---
title: Sprawozdanie Etap 3 - MongoDB
subtitle: Zaawansowane systemy baz danych
format:
  pdf:
    output-file: Etap 3 Sprawozdanie Krzysztof Dąbrowski 293101.pdf
    keep-tex: false
    # fig-pos: 'H'
---

{{< include ../shared/repo_callout.qmd >}}

# Wybrany zbór danych

W liceum zacząłem grać w grę karcianą [\acr{MTG}](https://magic.wizards.com/), która do dziś jest moim hobby.
Gra \acr{MTG} jest bardzo złożona, do tego stopnia, że za pomocą kart i mechanik _można zbudować maszynę Turinga_ @mtg-turing-complete. \
Gra zawiera bardzo wiele kart, z których każda ma zestaw parametrów zależnych od jej typu.
Poza cechami kart związanymi bezpośrednio z rozgrywką, karty mają też dodatkowe cechy takie jak sety, w których zostały wydane, grafikę, która może różnić się między wydaniami, czy też przynależność do talii lub legalność w danych formatach gry.
Istotnym cechą kart są też ich ceny, których zmienność prowadzi nawet do spekulacji cenowych i inwestycji niektórych graczy.

Z uwagi na moje zainteresowanie \acr{MTG}, oraz złożoność danych o kartach i relacji między nimi zdecydowałem się użyć zbioru na ten temat.
W tym celu skorzystałem z projektu MTGJSON @mtgjson:homepage, który jest otwarto źródłowym projektem katalogującym wiele informacji o \acr{MTG} w przenośnych formatach jak na przykład \acr{JSON}.

W ramach projektu dostępne są tysiące zbiorów danych, ponieważ dla każdej oficjalnej talii czy set'u dostępne są dedykowane zbiory.
Postanowiłem się skupić na formacie standard @magic-wizards:standard-format i jednym wybranym secie i talii.
Wybrałem więc zbiory:

- [AllPricesToday](https://mtgjson.com/downloads/all-files/#allpricestoday) - aktualne ceny każdego wydania dla każdej karty
- [DeckList](https://mtgjson.com/downloads/all-files/#decklist) - metadane każdej oficjalnej talii
- [SetList](https://mtgjson.com/downloads/all-files/#setlist) - metadane każdego dodatku
- [Keywords](https://mtgjson.com/downloads/all-files/#keywords) - słowa kluczowe z kart
- [CardTypes](https://mtgjson.com/downloads/all-files/#cardtypes) - typy kart
- [Standard](https://mtgjson.com/downloads/all-files/#standard) - podzbiór wszystkich kart legalnych w formacie standard @magic-wizards:standard-format
- [StandardAtomic](https://mtgjson.com/downloads/all-files/#standardatomic) - podstawowe informacje o kartach legalnych w formacie standard (bez rozróżnienia na różne wydania tej samej karty)
- set Edge of Eternities ([endpoint do pobrania informacji o wybranym dodatku](https://mtgjson.com/downloads/all-sets/))
- deck World Shaper - ([endpoint do pobrania informacji o wybranej talii](https://mtgjson.com/downloads/all-decks/))

Dane zawierają złożone struktury, wiele pól i referencje na dane z innych zbiorów.

# Instalacja MongoDB i wczytanie danych

Przygotowanie bazy MongoDB @mongodb:homepage.

## Instalacja MongoDB

Wybrałem wersję MongoDB Community, ponieważ chciałem skonfigurować lokalną wersję bazy i nie płacić za licencję wersji Enterprise.
Rozważałem też użycie MongoDB Atlas @mongodb:atlas-homepage, ale uznałem, że wolę lokalnie działającą wersję.

Ponieważ w poprzednich etapach dobrze sprawdzała mi się instalacja jako obraz Docker tym razem też się na to zdecydowałem.
Skonfigurowałem uruchomienie obrazu w pliku [`docker-compose.yml`](https://github.com/christopher-dabrowski/BoardBase/blob/main/docker-compose.yml), kierując się oficjalnym poradnikiem Install MongoDB Community Edition @mongodb:install-community-edition. \
Niestety oficjalna strona obrazu wersji community @docker:mongodb-community-server nie opisuje jakie są możliwe tagi, ani jak rozumieć zastosowane w nich skróty. Na szczęście strona do wersji open source obrazu MongoDB @docker:mongodb-official-image jest lepiej opisana. \
Nie byłem pewien, który obraz wybrać, ale sugerując się wątkiem na reddit @reddit:mongo-vs-mongodb-community-server pozostałem przy obrazie `mongodb/mongodb-community-server`. \
Dowiedziałem się, że jest on dostępny w wersji bazującej na Redhat i Ubuntu. Wybrałem wersję na Ubuntu, ponieważ mam większe doświadczenie z tą dystrybucją, choć pewnie nie będzie to miało znaczenia.

Po uruchomieniu kontenera połączyłem się do niego `mongosh` i pobrałem informacje o bazie poleceniem `db.runCommand({hello:1})` jak w samouczku @mongodb:install-community-edition. \
Zobaczyłem \acr{JSON} z informacjami o bazie, co potwierdza, że działą ona poprawnie.

Skonfigurowałem login i hasło użytkownika `root`, żeby ograniczyć dostęp do bazy. \
Rozważałem też ustawienie innych opcji @mongodb:configuration-file, ale uznałem, że na tym etapie domyślne ustawienia mi pasują.

## Wczytanie danych {#sec-data-import}

Na początku spróbowałem wczytać dane za pomocą \acr{Compass} @mongodb:compass.
Zorientowałem się jednak, że ponieważ [moje dane](https://github.com/christopher-dabrowski/BoardBase/tree/main/mongo/data) są pojedynczymi plikami \acr{JSON} to do kolekcji został dodany tylko jeden dokument zawierający wszystkie dane (@fig-compass-import).

![Wczytanie pliku za pomocą MongoDB Compass](img/compass-import.png){#fig-compass-import width=60%}

W dokumentacji przeczytałem, że dobrym sposobem na wczytanie danych z \acr{JSON} jest użycie narzędzia `mongoimport` razem z `jq` do transformacji danych @mongodb:mongoimport-guide.
Skrypty wczytujące dane umieściłem w katalogu [`mongo/importData/`](https://github.com/christopher-dabrowski/BoardBase/tree/main/mongo/importData).

Na początku miałem problem z uwierzytelnieniem. Udało mi się go rozwiązać kodując hasło w connection string używając URL encoding, zgodnie z przykładem z poradnika Decoding Encoded URLs in Linux @baeldung:decoding-encoded-urls-in-linux.

Po wczytaniu danych zauważyłem, że wszystkie pola mają typ `string`.
Przeczytałem, że w przypadku importu z \acr{JSON} wszystkie pola są zapisywane jako `string` @mongodb-community:mongoimport-date-handling.
Przygotowałem więc skrypty `.mongodb.js` w [`mongo/importData/`](https://github.com/christopher-dabrowski/BoardBase/tree/main/mongo/importData), które dostosowują typy we wczytanych dokumentach.

## Podział na kolekcje

Ponieważ projekt MTGJSON @mtgjson:homepage już rozsądnie grupuje różne rodzaje danych, to w mojej bazie załadowałem każdy ze zbiorów danych do osobnej kolekcji.
W przypadku niektórych zbiorów podzieliłem dane na mniejsze dokumenty. Zrobiłem tak na przykład w [`importKeywords.sh`](https://github.com/christopher-dabrowski/BoardBase/blob/main/mongo/importData/importKeywords.sh). \
Gdybym używał danych wielu tali lub setów umieściłbym je wszystkie w kolekcjach `decks` i `sets`. Jednak, ponieważ mam już wiele zestawów danych, to wybrałem tylko po jednej tali i secie.
Utworzone kolekcje są widoczne na @fig-collections.

![Utworzone kolekcje](img/loaded-data.png){#fig-collections}

## Relacje

Wybrane przeze mnie zbiory posiadają już za równo zagniezdzone dokumenty jak i referencje (@fig-nesting-and-reference).
Nie musiałem więc modyfikować ich struktury, poza zmianami, na które zdecydowałem się przy wczytywaniu danych (@sec-data-import).

Różnica między zagnieżdżeniem a referencją polega na tym, że w przypadku zagniezdzenia całe dane są przechowywane w bazowym dokumencie,
a referencja przechowuje tylko identyfikator danych w innym dokumencie. \
Referencja przypomina bardziej znormalizowany model relacyjny.
Stosując MongoDB zalecane jest jednak zagniezdzanie danych, gdy są one często czytane razem, ponieważ znacznie przyśpiesza to regularne działanie bazy @mongodb:data-modeling-best-practices. \

::: {#fig-nesting-and-reference layout="[50, -5, 50]"}

![Przykład zagniezdzonych danych](img/nesting-example.png)

![Przykład referencji](img/reference-example.png)

Przykładowe zagniezdzenie i referencja
:::


# Źródła {.unnumbered}

::: {#refs}
:::
