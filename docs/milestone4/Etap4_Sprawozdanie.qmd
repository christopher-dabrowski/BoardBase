---
title: Sprawozdanie Etap 4 - Neo4j
subtitle: Zaawansowane systemy baz danych
format:
  pdf:
    output-file: Etap 4 Sprawozdanie Krzysztof Dąbrowski 293101.pdf
    keep-tex: false
    # fig-pos: 'H'
---

{{< include ../shared/repo_callout.qmd >}}

# Zbiór danych

Wybrałem zbiór danych _Game of Graphs_ @github:game-of-graphs zawierający informacje o postaciach, rodach, rejonach i siedzibach rodów z serii książek Pieśń Lodu i Ognia (Gra o Tron) autorstwa George’a R.R. Martina @martin:game-of-thrones @martin:clash-of-kings @martin:storm-of-swords @martin:feast-for-crows @martin:dance-with-dragons.
Zdecydowałem się na ten zbiór, ponieważ jestem fanem fantastyki. Sądzę, że ciekawe będzie przeanalizowanie go.

Zbiór _Game of Graphs_ @github:game-of-graphs został przygotowany na podstawie danych z projektu An API of Ice And Fire @github:an-api-of-ice-and-fire.
W zbiorze bzowo występują 4 rodzaje węzłów oraz 17 rodzajów relacji widocznych na @fig-base-gog-schema.
Bazowy zbiór zawiera 2122 węzłów i 3233 relacji widocznych na podglądzie @fig-base-gog-data.

![Bazowy schemat danych Game of Graphs. Źródło: Repozytorium Game of Graphs @github:game-of-graphs](img/got-graphql-schema.jpg){#fig-base-gog-schema}

![Podgląd danych Game of Graphs. Źródło: Repozytorium Game of Graphs ](img/got-graph.jpg){#fig-base-gog-data}

Ponieważ bazowy zbiór _Game of Graphs_ @github:game-of-graphs zawiera tylko 4 rodzaje węzłów, dodam do niego typ węzła `Book` reprezentujący książki z serii.
Projekt _An API of Ice And Fire_ @github:an-api-of-ice-and-fire dostarcza endpoint pozwalający na pobranie informacji o książkach.
Nie został on jednak wykorzystany w bazowym zbiorze _Game of Graphs_ @github:game-of-graphs.

# Instalacja Neo4j i wczytanie danych

Przygotowanie bazy danych i wczytanie wstępnych danych.

## Instalacja

Wybrałem wersję Neo4j _Community Edition_, ponieważ jest ona darmowa @neo4j:editions. Nie potrzebuję funkcji dostępnych w wersji _Enterprise Edition_ @neo4j:editions.

Zdecydowałem się na użycie Docker'a, w celu zapewnienia replikowalności mojego środowiska.
Skonfigurowałem Neo4j jako kontener Docker w pliku [`docker-compose.yml`](https://github.com/christopher-dabrowski/BoardBase/blob/main/docker-compose.yml) , bazując na instrukcjach z dokumentacji Neo4j @neo4j:docker-getting-started @neo4j:docker-persisting-volumes.

Żeby skonfigurować Neo4j zdecydowałem się na pobranie domyślnych plików konfiguracyjnych, modyfikację ich i podmontowanie do kontenera. \
Bazową konfigurację pobrałem poleceniem `docker run --rm --volume=./neo4j/conf:/conf neo4j:2025.11.2 dump-config` bazując na dokumentacji @neo4j:docker-configuration.
Zwiększyłem dostępną pamięć i wyłączyłem telemetrię dostosowując plik [`neo4j.conf`](https://github.com/christopher-dabrowski/BoardBase/blob/main/neo4j/conf/neo4j.conf).

Skonfigurowałem również automatyczną instalację pluginu _APOC Core_ oraz skonfigurowałem go w pliku [`apoc.conf`](https://github.com/christopher-dabrowski/BoardBase/blob/main/neo4j/conf/apoc.conf), zgodnie z dokumentacją @neo4j:docker-plugins @neo4j:apoc-installation @neo4j:apoc-configuration.

Po uruchomieniu kontenera sprawdziłem czy Neo4j działa poprawnie, używając `cyhper-shell` @neo4j:cypher-shell. \
Możliwe jest też użycie _Aura Console_ do podłączenia się do lokalnej instancji Neo4j @neo4j:access, mi to jednak nie działało.
Zamiast tego, żeby móc korzystać z wizualizacji uruchomiłem wbudowany interfejs webowy <http://localhost:7474/browser>. \
Skonfigurowałem również rozszerzenie edytora kodu [Neo4j for VS Code](https://marketplace.visualstudio.com/items?itemName=neo4j-extensions.neo4j-for-vscode).

# Źródła {.unnumbered}

::: {#refs}
:::
