---
title: Projekt BoardBase
subtitle: Sprawozdanie z Etapu 1 - Zaawansowane systemy baz danych
format:
  pdf:
    output-file: Etap 1 Sprawozdanie Krzysztof Dąbrowski 293101.pdf
    toc: true
    lof: true
    # lot: true
    # fig-pos: 'H'
---

{{< include ../shared/repo_callout.qmd >}}

# Zmiany w diagramie ERD

Poprawiłem diagram \acr{ERD} @fig-erd, odnosząc się do uwag do _Case Study_. Wprowadziłem następujące zmiany:

- Usunąłem tablice słownikowe zastępując je bezpośrednimi atrybutami w tabelach,
- Usunąłem tabele _Collection_ tworząc bezpośrednią relację N:N między _User_ a _GameRelease_. Niestety straciłem w ten sposób informacje o nazwie kolekcji, ale nie wiem jak to rozwiązać,
- Dodałem tablicę _Location_, do monitorowania gdzie miały miejsce rozgrywki.
- Dodałem tablicę _Price_, pozwalającą śledzić ceny danego wydania. Tabela zawiera datę startu i końca obowiązywania ceny, żebyś śledzić jej zmiany w czasie,
- Dodałem tabelę _Award_, aby móc przechowywać informacje o nagrodach zdobytych przez gry planszowe.

```{mermaid}
%%| fig-align: left
%%| label: fig-erd
%%| fig-cap: Zaktualizowany diagram ERD
%%| file: ERD.mmd
%%| fig-width: 6
%%| fig-height: 8.5
```

# Utworzenie bazy danych

Wybrałem \acr{SZBD} PostgreSQL. Opis mojego wyboru i konfiguracji \acr{SZBD} przedstawiłem w [Case Study](https://github.com/christopher-dabrowski/BoardBase/blob/main/docs/case-study/CaseStudy.qmd).

## Schemat bazy danych

Sama baza danych `boardbase` została utworzona automatycznie na podstawie konfiguracji kontenera Docker. \
Przed utworzeniem tabel utworzyłem schemat bazodanowy `mian` z autoryzacją dla domyślnego użytkownika `postgres` zgodnie z dokumentacją @postgres-docs:createschema.

Po stworzeniu pierwszych tabl w schemacie `main` zauważyłem, że pisząc zapytania muszę nazwy razem ze schematem. Zastanowiło mnie to, ponieważ w przeszłości wykonywałem zapytania w innych bazach danych podając samą nazwę tabeli. Przeczytałem więcej dokumentacji @postgres-docs:ddl-schemas na temat działania schematów w PostgreSQL i znalazłem informację, że można skonfigurować domyślnie przeszukiwane schematy. \
Dowiedziałem się, że rekomendowaną praktyką jest dodanie schematu do domyślnego wyszukiwania, tak więc zrobiłem.

Po pewnym czasie zorientowałem się, że `SET search_path` działa tylko w biedzącej sesji. Ponieważ za każdym raziem chciałem korzystać ze schematu `main` zmieniłem `search_path` na poziomie bazy danych zgodnie z artykułem _How Do I Set/Change the Default Schema in PostgreSQL_ @commandprompt:how-to-set-change-default-schema-postgresql.

## Tabele

Na podstawie koncepcyjnego diagramu \acr{ERD} @fig-erd stworzyłem odpowiednie tabele. \
Do przechowania informacji o tym jak bardzo ktoś chce zagrać w daną grę ze swojej listy życzeń utworzyłem `ENUM` @postgres:enum-types. Do przechowania kategorii i mechanik używanych w grach użyłem tablic słownikowych.

Rozważałem czy utworzyć oddzielne tabele dla języków i walut. Zdecydowałem się odejść od \acr{3NF} w tym przypadku, ponieważ nazwy języków i walut praktycznie się nie zmieniają, a dodanie kolejnych tabel spowolniłoby odczytywanie danych.

Do przechowania danych tekstowych używam `VARCHAR` z ograniczeniem długości. Długości te wybrałem empirycznie na podstawie przykładowych wartości. \
Żeby dbać o poprawność wprowadzanych danych użyłem instrukcji `CONSTRAINT`, `UNIQUE` oraz kontroli "nullowości". \
Dla zależnych tabeli rozważyłem co powinno się stać, gdy zależne dane zostaną usunięte. Ustawiłem odpowiednie zachowania instrukcjami `ON DELETE`. \
Dla tabeli realizujących relacje N:N użyłem kluczy złożonych kierując się dyskusją na temat ze stackoverflow @stackoverflow:composite-key-in-associative-tables.

Po utworzeniu tabel wygenerowałem schemat logiczny bazy danych @fig-logical-db-schema, za pomocą narzędzia pgAdmin @pgadmin:homepage.

![Logiczny schemat bazy danych](logical-db-schema.png){#fig-logical-db-schema fig-cap="Schemat logiczny bazy danych"}

# Źródła {.unnumbered}

::: {#refs}
:::
