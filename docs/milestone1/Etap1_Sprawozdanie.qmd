---
title: Projekt BoardBase
subtitle: Sprawozdanie z Etapu 1 - Zaawansowane systemy baz danych
format:
  pdf:
    output-file: Etap 1 Sprawozdanie Krzysztof Dąbrowski 293101.pdf
    toc: true
    lof: true
    code-overflow: wrap
    # lot: true
    # fig-pos: 'H'
---

{{< include ../shared/repo_callout.qmd >}}

# Zmiany w diagramie ERD

Poprawiłem diagram \acr{ERD} @fig-erd, odnosząc się do uwag do _Case Study_. Wprowadziłem następujące zmiany:

- Usunąłem tablice słownikowe zastępując je bezpośrednimi atrybutami w tabelach,
- Usunąłem tabele _Collection_ tworząc bezpośrednią relację N:N między _User_ a _GameRelease_. Niestety straciłem w ten sposób informacje o nazwie kolekcji, ale nie wiem jak to rozwiązać,
- Dodałem tablicę _Location_, do monitorowania gdzie miały miejsce rozgrywki.
- Dodałem tablicę _Price_, pozwalającą śledzić ceny danego wydania. Tabela zawiera datę startu i końca obowiązywania ceny, żebyś śledzić jej zmiany w czasie,
- Dodałem tabelę _Award_, aby móc przechowywać informacje o nagrodach zdobytych przez gry planszowe.

```{mermaid}
%%| fig-align: left
%%| label: fig-erd
%%| fig-cap: Zaktualizowany diagram ERD
%%| file: ERD.mmd
%%| fig-width: 6
%%| fig-height: 8.5
```

# Utworzenie bazy danych

Wybrałem \acr{SZBD} PostgreSQL. Opis mojego wyboru i konfiguracji \acr{SZBD} przedstawiłem w [Case Study](https://github.com/christopher-dabrowski/BoardBase/blob/main/docs/case-study/CaseStudy.qmd).

## Schemat bazy danych

Sama baza danych `boardbase` została utworzona automatycznie na podstawie konfiguracji kontenera Docker. \
Przed utworzeniem tabel utworzyłem schemat bazodanowy `mian` z autoryzacją dla domyślnego użytkownika `postgres` zgodnie z dokumentacją @postgres-docs:createschema.

Po stworzeniu pierwszych tabl w schemacie `main` zauważyłem, że pisząc zapytania muszę nazwy razem ze schematem. Zastanowiło mnie to, ponieważ w przeszłości wykonywałem zapytania w innych bazach danych podając samą nazwę tabeli. Przeczytałem więcej dokumentacji @postgres-docs:ddl-schemas na temat działania schematów w PostgreSQL i znalazłem informację, że można skonfigurować domyślnie przeszukiwane schematy. \
Dowiedziałem się, że rekomendowaną praktyką jest dodanie schematu do domyślnego wyszukiwania, tak więc zrobiłem.

Po pewnym czasie zorientowałem się, że `SET search_path` działa tylko w biedzącej sesji. Ponieważ za każdym raziem chciałem korzystać ze schematu `main` zmieniłem `search_path` na poziomie bazy danych zgodnie z artykułem _How Do I Set/Change the Default Schema in PostgreSQL_ @commandprompt:how-to-set-change-default-schema-postgresql.

## Tabele

Na podstawie koncepcyjnego diagramu \acr{ERD} @fig-erd stworzyłem odpowiednie tabele. \
Do przechowania informacji o tym jak bardzo ktoś chce zagrać w daną grę ze swojej listy życzeń utworzyłem `ENUM` @postgres:enum-types. Do przechowania kategorii i mechanik używanych w grach użyłem tablic słownikowych.

Rozważałem czy utworzyć oddzielne tabele dla języków i walut. Zdecydowałem się odejść od \acr{3NF} w tym przypadku, ponieważ nazwy języków i walut praktycznie się nie zmieniają, a dodanie kolejnych tabel spowolniłoby odczytywanie danych.

Do przechowania danych tekstowych używam `VARCHAR` z ograniczeniem długości. Długości te wybrałem empirycznie na podstawie przykładowych wartości. \
Żeby dbać o poprawność wprowadzanych danych użyłem instrukcji `CONSTRAINT`, `UNIQUE` oraz kontroli "nullowości". \
Dla zależnych tabeli rozważyłem co powinno się stać, gdy zależne dane zostaną usunięte. Ustawiłem odpowiednie zachowania instrukcjami `ON DELETE`. \
Dla tabeli realizujących relacje N:N użyłem kluczy złożonych kierując się dyskusją na temat ze stackoverflow @stackoverflow:composite-key-in-associative-tables.

Po utworzeniu tabel wygenerowałem schemat logiczny bazy danych @fig-logical-db-schema, za pomocą narzędzia pgAdmin @pgadmin:homepage.

![Logiczny schemat bazy danych](logical-db-schema.png){#fig-logical-db-schema fig-cap="Schemat logiczny bazy danych"}

# Wypełnie bazy danymi

Do wygenerowania przykładowych danych użyłem \acr{LLM} Claude Sonet 4.5.

## Generowanie przykładowych danych

Najpierw przygotowałem plik z informacjami o strukturze bazy danych za pomocą narzędzia GitHub Copilot @github:copilot-homepage zintegrowanego z VS Code. Prompt którego użyłem:

> I'll need to generate real looking data for my database. Your task is to crate a LLM readable file describing the database scheema so the LLM can use it to create the sample data. See the #file:schema files to learn about the database

Na tej podstawie \acr{LLM} wygenerował plik [SCHEMA_DESCRIPTION.md](https://github.com/christopher-dabrowski/BoardBase/blob/main/sql/schema/SCHEMA_DESCRIPTION.md), który dostosowałem do moich potrzeb. \
Następnie na stronie <https://claude.ai/> wygenerowałem pliki z przykładowymi danymi. Tak wyglądała [moja konwersacja z agentem \acr{AI}](https://claude.ai/share/57272be2-05b8-493b-8f1a-3c8dbc72d03f).

## Wczytywanie danych

Przy próbie wczytania danych napotkałem problemy ze wstawieniem danych do tabeli `award`. Sprawdziłem, że ta tabela nie została utworzona. Okazało się, że zrobiłem drobne błędy składniowe i nie zauważyłem błędu podczas tworzenia tabel. Poprawiłem błędy i ponownie utworzyłem tabele.

Napotkałem kolejny problem z wczytaniem haszy haseł. Były one zaczytywane z notacji heksadecymalnej, która ma dość sztywny format. \acr{LLM} wygenerował niepoprawne wartości. Wygenerowałem haszhe ręcznie używając narzędzia online @emn178:sha256-hash-generator. \
Wiem, że hash sha256 nie jest najbezpieczniejszym rozwiązaniem. Mimo tego, do projektu zdecydowałem się go użyć ze względu na szybkość działania.

Przy kolejnej próbie wczytania danych napotkałem problem z kluczami głównymi w tabeli `user`. Ponieważ użyłem automatycznej sekwencji do generowania kluczy, to przy usunięciu i ponownym wczytaniu danych zostały one ponumerowane kolejnymi wartoścami sekwencji, a dane wygenerowane przez \acr{LLM} zakładały numerację od 1.
Rozwiązałem ten problem resetując sekwencję razem z usuwaniem danych zgodnie z odpowiedzią na forum @stackoverflow:reset-auto-increment-counter.

Po tych poprawach udało mi się wczytać całość wygenerowanych danych.

# Użytkownicy i uprawnienia

Do zarządzania uprawnieniami użyłem roli @postgres-docs:database-roles. \
Zacząłem od utworzenia roli grupowych `admins`, `players` i `guests`. Przypisałem im uprawnienia do odpowiednich typów zapytań w zależności od tabeli.

W kolejnym kroku utworzyłem użytkowników, po jednym dla każdej roli grupowej.

## Testy uprawnień

Zmieniłem rolę na `guest` i spróbowałem wstawić nową grę. \

```sql
SET role guest;
SELECT current_user, session_user;

INSERT INTO board_game (name, description, designer, declared_minimal_player_count, declared_maximum_player_count, declared_minimal_age) VALUES
('Catan', 'Trade, build, and settle the island of Catan.', 'Klaus Teuber', 3, 4, 10);
```

W odpowiedzi otrzymałem błąd `permission denied for table board_game`.

Przetestowałem też czy użytkownik `guest` może odczytać dane z tabeli `board_game`. Zapytanie wykonało się poprawnie.

Następnie przetestowałem czy użytkownik `casual_gamer` może dodać ocenę do gry.

```sql
SET role casual_gamer;
SELECT current_user, session_user;

INSERT INTO rating (user_id, board_game_id, enjoyment) VALUES
((SELECT user_id FROM app_user WHERE username = 'casual_gamer'),
 (SELECT game_id FROM board_game WHERE name = 'Catan'),
 8);
```

Zapytanie wykonało się poprawnie.

Na koniec przetestowałem czy użytkownik `god` może usunąć dopier co dodaną ocenę.

```sql
SET role god;
SELECT current_user, session_user;

DELETE FROM rating WHERE rating_id = 12;
```

Zapytanie wykonało się poprawnie.

Po tych testach spodziewam się, że uprawnienia zostały poprawnie skonfigurowane.

# Źródła {.unnumbered}

::: {#refs}
:::
