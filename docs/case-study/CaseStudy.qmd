---
title: BoardBase Case Study
subtitle: Zaawansowane systemy baz danych - Projekt Etap 1
bibliography: ../references.bib
csl: ../diabetologia.csl
link-citations: true
mermaid-format: png
author:
  - name: Krzysztof Dąbrowski 293101
    id: kd
    email: krzysztof.dabrowski7.stud@pw.edu.pl
    affiliation: Politechnika Warszawska
lang: pl
# format: html
format:
  pdf:
    documentclass: scrartcl
    papersize: A4
    toc: false
    number-sections: true
    colorlinks: true
filters:
  - acronyms
acronyms:
  fromfile: ../glossary.yaml
  include_unused: false
  insert_links: true
  loa_header_classes:
    - unnumbered
  loa_title: Zastosowane skróty
  insert_loa: end
  sorting: alphabetical
---

::: {.callout-note title="Kod projektu"}
Kod projektu i sprawozdań jest dostępny na GitHub [BoardBase ![](https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png){width=20}](https://github.com/christopher-dabrowski/BoardBase)
:::

# Koncepcja Systemu

Wielu miłośników gier planszowych chciałoby wiedzieć jakie gry planszowe są dostępne na rynku czy w jakich wersjach zostały wydane czy móc łatwo sprawdzić inne informacje o grach planszowych. \
Aplikacja bazodanowa _BoardBase_ pomoże rozwiązać te problemy.

W ramach aplikacji _BoardBase_ będą przechowywane dane o grach planszowych, ich kategorii, mechanikach, ocenach graczy oraz rozgrywanych partiach. Dzięki temu gracze będą mogli wyszukać informacje o interesujących ich tytułach.
Gracze będą mogli dzielić się swoimi ocenami gier oraz recenzjami. Na tej podstawie generowane będą rankingi najciekawszych gier.

Użytkownicy będą mogli monitorować swoją kolekcję gier oraz rozgrywane partie oraz interesujące ich gry, których zakup rozważają.

Administratorzy będą dodawać nowe gry do katalogu.

Dzięki tym funkcjom aplikacja _BoardBase_ ułatwi znajdowanie interesujących graczy gier oraz dowiadywanie się więcej na temat ich ulubionych tytułów.

## Dane przechowywane w bazie

Główne informacje, które będą przechowywane.

- Informacje o grach planszowych
- Kategorie i mechaniki gier w postaci słowników
- Dane użytkowników
- Oceny gier
- Recenzje gier
- Kolekcje gier danych użytkowników
- Lisy życzeń użytkowników
- Dziennik partii gier użytkowników


## Użytkownicy systemu

Role dostępne w systemie.

- Gość: przegląda katalog i recenzje
- Użytkownik: ocenia gry, pisze recenzje, prowadzi kolekcję i dziennik partii
- Administrator: zarządza danymi gier, kategoriami

## Usługi udostępniane użytkownikom

Przypadki użycia systemu.

- Wyszukiwanie gier w katalogu
- Oglądanie rankingów gier
- Wyszukanie podobnych tytułów do wskazanej gry
- Podgląd szczegółowych informacji o grze
- Ocena gry w postaci gwiazdek lub punktów
- Napisanie recenzji gry
- Katalogowanie posiadanych gier
- Rejestracja rozegranych partii
- Uwierzytelnianie: rejestracja/logowanie
- Zapisywanie gier na listę życzeń

# Wybrany \acr{SZBD}

Słyszałem, że \acr{SZBD} Postgres pozwala na instalowanie wielu modułów, które znacząco rozwijają jego działanie @youtube:IReplacedMyEntireTechStackWithPostgres. Możliwe, że nie będę korzystał z nich w tym projekcie, ale mimo tego uznałem to za bardzo ciekawe. Z tego powodu wybieram \acr{SZBD} **Postgres**. \
Dodatkowo nie używałem wcześniej Postgresa i chcę się go nauczyć.

## Instalacja

Zastanawiałem się czy zainstalować Postgress bezpośrednio na komputerze, czy uruchomić go w kontenerze Docker. Skłaniałem się w strone kontenera, ponieważ instalacja wydaje sie znacznie prostsza. Planuję też uruchamiać mój projekt na komputerze z systemem Windows i Mac OS, co wydaje się również łatwiejsze z użyciem kontenera.
Nie byłem pewny czy zastosowanie kontenera jest dobrą praktyką w środowiskach produkcyjnych, ale przeczytanie dyskusji Why not run production postgres in docker? @reddit:WhyNotRunProductionPostgresInDocker rozwiało moje wątpliwości.

## Konfiguracja

W celu skonfigurowania \acr{SZBD} postanowiłem dostosować przykładowy plik konfiguracyjny. Zgodnie z oficjalną instrukcją @docker:HowToUseThePostgresDockerOfficialImage i dokumentacją, do której odnosi @github:docker-library-readme, skopiowałem plik `/usr/share/postgresql/postgresql.conf.sample` z kontenera do mojego projektu i dostosowałem go do moich potrzeb.

Nie mam jeszcze zbyt dużej wiedzy o konfiguracji \acr{SZBD} Postgres, więc zostawiłem większość ustawień na wartościach domyślnych.

Pozostawiłem odkomentowane ustawienia
```conf
listen_addresses = '*'
autovacuum_worker_slots = 16
```
oraz ustawiłem kilka ustawień związanych z logowaniem, żeby mieć więcej informacji o działaniu \acr{SZBD} i potencjalnych problemach.
Lekko zwiększyłem też dostępną pamięć, ponieważ mam zapas RAMu na komputerze, a oryginalne ustawienia wydawały mi się niskie. Zmieniłem też nazwę pliku logów na granularność na poziomie dnia, ponieważ nie będę potrzebował większej ilości plików logów.
```conf
shared_buffers = 256MB
work_mem = 8MB
log_filename = 'postgresql-%Y-%m-%d.log'
log_duration = on
log_statement = 'all'
track_io_timing = on
track_functions = all
```

Żeby wczytać konfigurację w obrazie Postgres skonfigurowałem w pliku _docker-compose.yml_ opcje `command: -c config_file=/etc/postgresql.conf` i `volumes: - ./postgresql.conf:/etc/postgresql.conf`.

## Testowanie działania

Aby sprawdzić czy \acr{SZBD} działa poprawnie uruchomiłem kontener z moim plikiem konfiguracyjnym.

Połączyłem się do bazy za pomocą `psql` i sprawdziłem czy działa poprawnie. \
Polecenie `SELECT version();` zwróciło poprawną wersję: `PostgreSQL 18.0 (Debian 18.0-1.pgdg13+3) on x86_64-pc-linux-gnu, compiled by gcc (Debian 14.2.0-19) 14.2.0, 64-bit`. \
Oznacza to, że \acr{SZBD} działa i odpowiada na zapytania.

# Diagram \acr{ERD}

Wysokopoziomowy model relacji przedstawiony na @fig-erd.

```{mermaid}
%%| label: fig-erd
%%| file: ERD.mmd
%%| fig-width: 6
```

# Źródła {.unnumbered}

::: {#refs}
:::
